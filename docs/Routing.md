
# Маршрутизация. SimpleMVC


Как уже было [сказано ранее](Start.md), SMCV реализует концепцию MVC.

Что это означает на практике? Обычно то, что запрос пользователя (каким бы он ни был) _всегда_ обрабатывается действием какого-то контроллера -- т.е. вызывается код, написанный в контроллере и уже код этого контроллера "решает", что делать дальше

 При этом, опять же, на практике в SMVC справедливы следующие утверждения:
 * **Контроллер** - это класс, унаследованный от родительского класса контроллера из репозитория ядра _(см. раздел о разделении универсальной и частной логики в SMVC)_.
 * **Действие контроллер** (action, "экшн") -- метод класса контроллера, отвечающий за какую-то конкретную задачу. Например, за получение списка статей (из СУБД или как-то ещё), или за вывод формы редактирования пользователя и обработку запроса, приходящего в результате отправки этой формы пользователем.

## Главный вопрос маршрутизации

Далее рассмотрим подробнее _как именно система понимает какой именно контроллер следует использовать_.
## Схема работы прихожения

Кратко описать процесс работы фреймворка можно так:

1. У Приложения есть единственный файл (т.н. "**точка входа**" в нашем случае это файл [web/index.php](https://github.com/it-for-free/SimpleMVC-example/blob/master/web/index.php)), с которого начинается обработка _любого_ запроса пришедшего от клиента (см. [подробнее о Клиент-Серверной архитектуре](http://fkn.ktu10.com/?q=node/9330)). Т.е. это означается что _все_ скрипты нашего сайта начинают работать именно с этого файла.
2. В точке входа Приложение получается экземпляр класса `\ItForFree\SimpleMVC\Application` ([см. реализацию](https://github.com/it-for-free/SimpleMVC/blob/master/src/Application.php) - отвечает за работу ядра в целом, подключая по мере необходимости другие части ярда), устанавливает ему конфигурацию (о получении конфигурции поговорим в следующих разделах) и запускает его, вызвав метод `run()`:
 
 ```php
 \ItForFree\SimpleMVC\Application::get()
    ->setConfiguration($config)
    ->run();
 ```
3. Вызов метода `run()` фактически запускает функционал ядра, который, анализируя текущее состояние адреса страницы (URL), принимает решение о том, _какой контроллер отвечает за данный адрес_ и какое именно _действие котроллера_ должно быть вызвано (фрагмент кода из метода ):

```php
// .....
$route = $this->getConfigObject('core.url.class')::getRoute();
/**
* @var \ItForFree\SimpleMVC\Router
*/
$Router = $this->getConfigObject('core.router.class');
$Router->callControllerAction($route); // определяем и вызываем нужно действие контроллера
// .....
```
-- как видим за процесс определения имени контроллера, имени действий и их вызов происходят в методе `callControllerAction()`, реализованном  уже другой классе Ядра, а именно `\ItForFree\SimpleMVC\Router` ([исх. код](https://github.com/it-for-free/SimpleMVC/blob/master/src/Router.php)).


**Ещё раз схема работы, но теперь кратко**

Таким, образом можно сказать, что взаимодействие Приложения и Ядра в части маршрутизации проходят по цепочке в таком порядке (по времени работы кода Приложения или Ядра):

 1. `Приложение` (запускает функционал ядра через `Applliction->run()` в своей точке входа)
 2. `Ядро` (используя свои классы определяет контроллер и действие, соответствующие маршруту (url) создает экземпляр контроллера и вызывает на нем метод)
 3. `Приложение` (выполняется код действий контроллера, и все что это действие вызовет)



